:PROPERTIES:
:title: readwise/翻译一下我自己之前写的英文文章： 几个月后，我...
:END:


* metadata
:PROPERTIES:
:author: [[himself_65 on Twitter]]
:full-title: "翻译一下我自己之前写的英文文章： 几个月后，我..."
:category: [[tweets]]
:url: https://twitter.com/himself_65/status/1745342123421978982
:image-url: https://pbs.twimg.com/profile_images/1710703282304212992/cf41FnRD.jpg
:END:

* Highlights first synced by [[Readwise]] [[2024-01-12]]
** 📌 [[2024-01-12]]
#+BEGIN_QUOTE
翻译一下我自己之前写的英文文章：

几个月后，我觉得我没有开发local-first的笔记App的必要。几年前，我读到这篇论文https://t.co/VdDlVUE1gQ，发现本地优先这个想法非常酷。于是我尝试在一家创业公司和另一家创业公司开发了一些App。我的看法是：天下没有免费的午餐。

我觉得CRDT只能用于一些笔记或绘图应用程序。就好比区块链，可能只能用于钱包。人们可能会说：面包，不是这样。你可以把区块链放到游戏中（就像确实一些创业公司那样）。

但天下没有免费的午餐；如果你这样做，开发的游戏只能提供一些无聊和基本的体验，所以为什么不直接打开Unity，用C#立马写一个MVP？当然理想情况下，CRDT可以放入任何情况，比如数据库，甚至是渲染DOM……但so what？为什么要脱了裤子放屁？我觉得很多创业公司来说他们就是在拿着锤子找钉子。

更具体地看，CRDT的开发体验远比其他技术差。其他技术，比如如SSR或React中的RSC。至少你可以给用户看之前看到报错；然后你可以发推特黑next.js，然后开始debug。但对于这样的local-first CRDT App，App发布到客户端之后，一切都将是未知的。无法想象出客户端的某个边缘情况会导致整个应用程序崩溃。我觉得可能是因为传统的本地优先应用程序（如PWA）在客户端运行代码，但数据仍在服务器上；开发者仍然会知道数据上发生了什么（如果你觉得UI=f(data)对的）。但对于CRDT来说，数据的源头和结果都在客户端，即使UI = f(data)是正确的，你有f，但你不知道输入，你得到一个错误的UI。我们应该如何枚举错误呢？

但当然有解决方法：加更多日志，做更多备份，做更多监控......然后就遇到了性能问题，所以这就是我觉得的的没有免费的午餐。

然而，我仍然相信CRDT在许多情况下是非常有想法的，更有意义（如绘图，笔记）。但这并不涉及更一般的情况，也不意味着用户会关心它。 
#+END_QUOTE\
** 📌 [[2024-01-12]]
#+BEGIN_QUOTE
我觉得这个观点也很有意思

https://t.co/nCimeX6wmu 
#+END_QUOTE\