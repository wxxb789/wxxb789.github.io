* [02]OOP

** UML 中的 OOP 概念以及在 Java 中的实现
*** UML 关系
1. 实现 Realization
2. 泛化 Generalization
3. 关联 Association
4. 依赖 Dependency
5. 聚合 Aggregation
6. 组合 Composition

** 1. 封装


1. 隐藏实现细节，只对外提供公共的访问方式

** 2. 继承


1. 当多个类中定义了共享内容(相同的成员属性和相同的成员方法)时
2. 为了提高代码的复用性以及建立类与类之间的关联关系
3. 将多个类中的共享内容抽取出来定义在一个独立的类中
4. 其他类只需要继承这个独立的类，就会将这个独立的类中的定义的所有共享内容继承
5. 将定义了共享内容的类称之为父类(超类 基类)
6. 继承了父类的类称为子类。
7. java支持单继承不支持多继承，可以通过多重继承/多实现解决此局限性

*** 2.1. 继承子父类间成员属性的特点


1. 父有子无，子类使用继承自父类的
2. 子有父无，子类使用自己的
3. 子父类中存在同名的成员变量，依据就近原则，访问子类自己的
4. 子父类中存在同名的成员变量时

   1. 没有标识/被this标识的成员变量都是子类自己的
   2. 被super标识的就是继承自父类的

5. 父类中的私有属性子类可以继承，但只能间接访问
6. 子父类间的静态成员也存在继承

*** 2.2. 继承子父类间成员函数的特点


1. 父有子无，子类使用继承自父类的
2. 子有父无，子类使用自己的
3. 子父类间出现相同的方法，子类使用自己的覆盖父类的方法
4. 子父类间出现覆盖的方法

   1. 没有标识/被this标识的都是子类覆盖父类的方法
   2. 被super标识的是子类继承自父类的方法

*** 2.3. 继承子父类间构造器的特点


1. 子类所有的构造器的第一句都默认隐藏存在一个super();表示调用父类无参的构造器;

   1. 子类对父类的继承底层是靠子类的构造器对父类构造器的访问，进而得到父类的内部结构并继承;

2. 当父类中提供的重载的带参的构造器，且没有显现的定义无参构造器

   1. 可以在子类所有构造器的第一句使用super(参数列表);表示访问父类带参的构造器;

3. 解决this/super冲突

   1. 创建子类对象直接调用的子类构造器中不再使用super(参数列表);去访问父类构造器
   2. 只使用this(参数列表);访问子类重载的构造器
   3. 将使用super(参数列表);访问父类构造器的任务交给使用this(参数列表);所访问的重载的构造器

** 3. 多态


1. 事物的多种形态/表现形式
2. 面向对象的多态一般指对象的多种形态，即父类或接口的引用指向子类或实现类对象，可以提高代码的灵活性;
3. 多态的前提就是必须存在继承或实现关系;

*** 3.1. 多态子父类间属性的特点


1.  父有子无，访问父类

2.  父无子有，不能访问，否则报错

3.  子父类间出现同名的属性访问仍是父类的

4.  多态虽然是父类/接口引用指向子类/实现类对象，但是引用使用是父类的引用，而属性不存在覆盖一说，所以始终访问的父类的


*** 3.2. 多态子父类间方法的特点


1.  父有子无，访问父类

2.  父无子有，不能访问，否则报错

3.  子父类间出现相同的方法，子类的方法会覆盖父类的方法，此时调用子类覆盖父类的方法

4.  多态只应用在子父类间覆盖的方法

5. 子父类间的静态方法存在继承，但不存在覆盖，在多态中父类引用代表的就是父类，静态方法属于各自类，故即使子父类间出现了相同的静态方法访问也是父类该方法

** 4. 接口

*** 4.1. 默认方法冲突


1. 超类优先
2. 接口冲突

*** 4.2. Cloneable接口

** 5. 对象创建的顺序

** 6. 类的加载顺序

