

* lifetime 是一种泛型。
生命周期（lifetimes），它是一类允许我们向编译器提供引用如何相互关联的泛型。

#+begin_src rust
{
    let r;
 {
        let x = 5;
        r = &x;
    } // x has dropped
 println!("r: {}", r);
}
#+end_src

* 生命周期解决的问题
** 悬垂引用
* Borrow Checker 借用检查器
* 函数中的泛型生命周期
* 生命周期标注语法
生命周期标注有着一个不太常见的语法：生命周期参数名称必须以撇号 ='= 开头，其名称通常全是小写，类似于泛型其名称非常短。
='a= 是大多数人默认使用的名称。生命周期参数标注位于引用的 =&= 之后，并有一个空格来将引用类型与生命周期标注分隔开。

单个生命周期标注本身没有多少意义，因为生命周期标注告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。
例如如果函数有一个生命周期 ='a= 的 i32 的引用的参数 first。还有另一个同样是生命周期 ='a= 的 =i32= 的引用的参数 second。这两个生命周期标注意味着引用 first 和 second 必须与这泛型生命周期存在得一样久。

#+begin_quote
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
#+end_quote

#+begin_src rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src
* 生命周期省略规则（lifetime elision rules）
函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），而返回值的生命周期被称为 输出生命周期（output lifetimes）
编译器采用三条规则来判断引用何时不需要明确的标注。
** 第一条规则是每一个是引用的参数都有它自己的生命周期参数。
** 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数
** 第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，说明是个对象的方法(method)(译者注： 这里涉及 Rust 的面向对象参见 17 章), 那么所有输出生命周期参数被赋予 self 的生命周期。
* 方法定义中的生命周期标注
* 静态生命周期
这里有一种特殊的生命周期值得讨论： ='static= ，其生命周期能够存活于整个程序期间。所有的字符串字面量都拥有 ='static= 生命周期
* 结合泛型类型参数、trait bounds 和生命周期
