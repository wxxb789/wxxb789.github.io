#+tags: roadmap,

* ecosystem
** junit
** mockito
** jmeter
** dump
*** jstack
*** jstat
*** jmap
*** jhat
*** Arthas
*** dump分析死锁
*** dump分析内存泄露
* concurrency
:PROPERTIES:
:collapsed: true
:END:
** 线程
*** 线程的实现
*** 线程的状态
*** 线程优先级
*** 线程调度
** 多线程如何Debug
** 守护线程
** 创建线程的多种方式
** 继承Thread类创建线程
** 实现Runnable接口创建线程
** 通过Callable和FutureTask创建线程
** 通过线程池创建线程
** 线程池
** 自己设计线程池
** =submit()= 和 =execute()=
** 线程池原理
** 为什么不允许使用Executors创建线程池
** 线程安全
** 什么是线程安全
** 多级缓存和一致性问题
** CPU时间片和原子性问题
** 指令重排和有序性问题
** 线程安全和内存模型的关系
** =happens-before=
** =as-if-serial=
** 锁
** 可重入锁
** 阻塞锁
** 乐观锁与悲观锁
** 数据库相关锁机制
** 分布式锁
** 无锁
** CAS
*** CAS的ABA问题
** 锁优化
** 偏向锁
** 轻量级锁
** 重量级锁
** 锁消除
** 锁粗化
** 自旋锁
** 死锁
** 什么是死锁
** 死锁的原因
** 如何避免死锁
** 写一个死锁的程序
** 死锁问题如何排查
** synchronized
*** synchronized是如何实现的？
*** synchronized和lock之间关系
*** 不使用synchronized如何实现一个线程安全的单例
*** synchronized和原子性
*** synchronized和可见性
*** synchronized和有序性
** volatile
*** 编译器指令重排和CPU指令重排
*** volatile的实现原理
*** 内存屏障
*** volatile和原子性
*** volatile和可见性
*** volatile和有序性
*** 有了symchronized为什么还需要volatile
** 线程相关方法
*** start & run
*** sleep & wait
*** notify & notifyAll
** ThreadLocal
*** ThreadLocal 原理
*** ThreadLocal 底层的数据结构
** 写代码解决生产者消费者问题
** 并发包
** 同步容器与并发容器
* distributed
** concepts
:PROPERTIES:
:collapsed: true
:END:
*** 分布式与集群
*** 数据一致性
*** 服务治理
*** 服务降级
*** 分布式理论
*** 2PC
*** 3PC
*** CAP
*** BASE
*** 分布式协调 Zookeeper
*** 基本概念
*** 常见用法
*** ZAB算法
*** 脑裂
*** 分布式事务
*** 本地事务&分布式事务
*** 可靠消息最终一致性
*** 最大努力通知
*** TCC
*** Dubbo
*** 服务注册
*** 服务发现
*** 服务治理
*** 分布式数据库
*** 怎样打造一个分布式数据库
*** 什么时候需要分布式数据库
*** mycat
*** otter
*** HBase
*** 分布式文件系统
*** mfs
*** fastdfs
*** 分布式缓存
*** 缓存一致性
*** 缓存命中率
*** 缓存冗余
*** 限流降级
*** 熔断器模式
*** Hystrix
*** Sentinal
*** resilience4j
*** 分布式算法
*** 拜占庭问题与算法
*** 2PC
*** 3PC
*** 共识算法
*** Paxos 算法与 Raft 算法
*** ZAB算法
*** 领域驱动设计
*** 实体、值对象
*** 聚合、聚合根
*** 限界上下文
*** DDD如何分层
*** 充血模型和贫血模型
*** DDD和微服务有什么关系
* 高可用
** 双机架构
** 主备复制
** 主从复制
** 主主复制
** 异地多活
** 高性能
** 高性能数据库
** 读写分离
** 分库分表
* 高性能
** 缓存
** 缓存穿透
** 缓存雪崩
** 缓存热点
** 负载均衡
** PPC、TPC