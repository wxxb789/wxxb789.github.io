* [01]JavaBasics
** 1. 数据类型
*** 1.1. 基本数据类型

| 数据类型         | 占用字节数 | 取值范围                     | 默认值   |
|------------------+------------+------------------------------+----------|
| boolean          | 1          | =true=,=false=               | =false=  |
| byte             | 1          | -128-127                     | 0        |
| short            | 2          | $[-2^{15},2^{15} -1]$        | 0        |
| int              | 4          | $[-2^{31},2^{31} -1]$        | 0        |
| long             | 8          | $[-2^{63},2^{63} -1]$        | 0        |
| char             | 2          | $[0,2^{16} -1]$或$[0,65535]$ | '\u0000' |
| float(IEEE 754)  | 4          | $[1.4013E-45,3.4028E+38]$    | 0.0F     |
| double(IEEE 754) | 8          | $[4.9E-324,1.7877E+308]$     | 0.0D     |
**** 1.1.1. =short s1=1;s1=s1+1;=与=short s1=1;s1+=1;=


- 对于=short s1=1;s1=s1+1;=来说，在=s1+1=运算时会*自动提升*表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。
- 对于=short s1=1;s1+=1;=来说
  +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
**** 1.1.2. Integer与int的区别

int是java的8种基本数据类型之一。Integer是Java为int类型提供的封装类。int变量的默认值为0，Integer变量的默认值为null，这一点说明Integer可以区分出未赋值和值为0的区别，比如说一名学生没来参加考试，另一名学生参加考试全答错了，那么第一名考生的成绩应该是null，第二名考生的成绩应该是0分。Integer类内提供了一些关于整数操作的一些方法。
**** 1.1.3. char类型变量能不能存放一个中文汉字？


#+begin_html
  <!--TODO-->
#+end_html

char类型变量是用来储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的。如果某个生僻字没有包含在unicode编码字符集中，那么char就不能存储该生僻字。
**** 1.1.4. switch语句可以作用的变量类型？

在switch(expr1)中，expr1只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或Integer包装类型。由于，byte,short,char都可以隐式转换为int，所以，这些类型以及这些类型的包装类型也是可以的。long不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。

#+begin_quote
  A switch works with the byte, short, char, and int primitive data
  types. It also works with enumerated types (discussed in Enum Types),
  the String class, and a few special classes that wrap certain
  primitive types: Character, Byte, Short, and Integer (discussed in
  Numbers and Strings).

  =switch=允许的类型：char,byte,short,int,Character,Byte,Short,Integer,String,enum
#+end_quote
*** 1.2. 引用数据类型
*** 1.3. =null=
** 2. OOP
*** 2.1. 重载，重写，封装，继承与多态
**** 2.1.1. 重载，重写


- 重载：
  发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
- 重写：
  发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为
  private 则子类就不能重写该方法。

在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以
Constructor 也就不能被 override（重写）,但是可以
overload（重载）,所以你可以看到一个类中有多个构造函数的情况。
**** 2.1.2. 封装，继承，多态


- *封装*把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
- *继承*是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
- *多态*就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。（Java中有两种形式可以实现多态：1.
  继承，子类对父类方法的重写 2. 接口，实现接口并覆盖接口中同一方法）
*** 2.2. 接口 vs 抽象类


- 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8
  开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
- 接口中的实例变量默认是 final 类型的，而抽象类中则不一定。
- 一个类可以实现多个接口，但最多只能实现一个抽象类。
- 一个类实现接口的话要实现接口的所有方法，而抽象类不一定。
- 接口不能用 new
  实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

#+begin_quote
  备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。
#+end_quote
**** 2.2.1. 抽象类必须要有抽象方法吗？

抽象类中不一定包含抽象方法，但是包含抽象方法的类一定要被声明为抽象类。
**** 2.2.2. 抽象类能使用 final 修饰吗？

抽象类不能用final来修饰。当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法，这明显违背了抽象类存在的意义了。