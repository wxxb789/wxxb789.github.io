* 暴力递归就是尝试
1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解
* 例题
** 2.1. 汉诺塔

#+begin_quote
  打印 n 层汉诺塔从最左边移动到最右边的全部过程
#+end_quote
** 2.2. 打印全部子序列
#+begin_quote
  打印一个字符串的全部子序列，包括空字符串
#+end_quote
** 2.3. 全排列


#+begin_quote
  打印一个字符串的全部排列，要求不要出现重复的排列
#+end_quote
** 2.4. 递归实现逆序栈


#+begin_quote
  给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。
  如何实现？
#+end_quote
** 2.5. 字符串转化


#+begin_quote
  规定1和A对应、2和B对应、3和C对应...
  那么一个数字字符串比如"111"，就可以转化为"AAA"、"KA"和"AK"。
  给定一个只有数字字符组成的字符串 string，返回有多少种转化结果。
#+end_quote
** 2.6. 背包


#+begin_quote
  给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表
  i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物
  品不能超过这个重量。返回你能装下最多的价值是多少？
#+end_quote
** 2.7. 纸牌游戏


#+begin_quote
  给定一个整型数组
  array，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸
  牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A
  和玩家B都绝顶聪明。请返回最后获胜者的分数。

  【举例】 =arr=[1,2,100,4]=。
  开始时，玩家A只能拿走1或4。如果开始时玩家A拿走1，则排列变为[2,100,4]，接下来
  玩家 B可以拿走2或4，然后继续轮到玩家A...
  如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继
  续轮到玩家A...
  玩家A作为绝顶聪明的人不会先拿4，因为拿4之后，玩家B将拿走100。所以玩家A会先拿1，
  让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家
  A拿走。玩家A会获胜， 分数为101。所以返回101。 arr=[1,100,2]。
  开始时，玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，
  分数为100。所以返回100。
#+end_quote
** 2.8. N皇后

#+begin_quote
  N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，
  也不在同一条斜线上。 给定一个整数 n，返回 n 皇后的摆法有多少种。
  n=1，返回1。 n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。
  n=8，返回92。
#+end_quote
*