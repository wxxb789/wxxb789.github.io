#+tags: algo,

* 1. 哈希表的简单介绍

1. 哈希表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用HashSet结构(C++中叫UnOrderedSet)
3. 如果既有key，又有伴随数据value，可以使用HashMap结构(C++中叫UnOrderedMap)
4. 有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事
5. 使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 $O(1)$ ，但是常数时间比较大
6. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
7. 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小

* 2. 有序表的简单介绍

#+begin_quote
  关于有序表结构的增删改查性能都是$O(\log{N})$
#+end_quote

1. 有序表在使用层面上可以理解为一种集合结构
2. 如果只有key，没有伴随数据value，可以使用TreeSet结构(C++中叫OrderedSet)
3. 如果既有key，又有伴随数据value，可以使用TreeMap结构(C++中叫OrderedMap)
4. 有无伴随数据，是TreeSet和TreeMap唯一的区别，底层的实际结构是一回事
5. 有序表和哈希表的区别是，有序表把key按照顺序组织起来，而哈希表完全不组织
6. [[红黑树]]、[[AVL树]]、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现
   不同
7. 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
8. 放入哈希表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占
   用是这个东西内存地址的大小
9. 不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度
** 2.1. 有序表结构的实现

1. [[AVL树]]
2. [[SB树]]
3. [[红黑树]]
4. [[跳表]]

* 3. 有序表的固定操作

1. =boolean isEmpty()=返回是否为空 $O(1)$
2. =int size()=返回有序表的大小 $O(1)$
3. =void put(K key, V value)=将一个记录=(key,value)=加入到表中，或者将key的记录更新成value
4. =V get(K key)=根据给定key查询value并返回
5. =void remove(K key)=移除key的记录
6. =boolean containsKey(K key)=查询是否有关于key的记录
7. =K firstKey()=返回所有键值排序结果中最左（小）的那一个
8. =K lastKey()=返回所有键值排序结果中，最右（大）的那个
9. =K floorKey(K key)=如果表中存入过key，返回key，否则返回所有键值排序结果中key的前一个
10. =K ceilingKey(K key)=如果表中存入过key，返回key，否则返回所有键值排序结果中key的后一个

#+begin_quote
  以上所有操作时间复杂度都是 $O(\log{N})$ ，$N$为有序表含有的记录条数。

  1. 引用类型要有比较器或者实现=Comparable=接口
  2. 迭代的同时使用添加/删除操作会出错（会抛出=ConcurrentModificationException=异常。因为add，remove操作有可能改变有序表结构），应该创建一个新容器，在迭代时记录要删除的key，迭代结束后，统一删除
#+end_quote

* 4. 链表的结构

#+begin_src java
  // 单链表结构
  class Node<V>{
    V value;
    Node next;
  }

  // 双链表结构
  class Node<V>{
    V value;
    Node next;
    Node last;
  }
#+end_src

#+begin_quote
  单链表和双链表只需要给定一个头部节点head，就可以找到剩下的节点。
#+end_quote

** 4.1. 反转单向和双向链表

#+begin_quote
  要求时间复杂度：$O(N)$，空间复杂度：$O(1)$，结果返回新的头节点
#+end_quote

#+begin_src java
  // todo
#+end_src

** 4.2. 打印两个有序链表的公共部分

#+begin_quote
  工共部分指有相同的value，而非公共的节点（同一个节点）
#+end_quote

#+begin_src java
  // todo 使用两个指针，移动较小值的指针，相同打印，不同则继续移动较小值的指针
#+end_src

** 4.3. 判断一个链表是否为回文结构

#+begin_quote
  1->2->1返回true，1->2->2->1返回true，1->2->3返回false
#+end_quote
*** 4.3.1. 简单解法（使用额外数据结构）

#+begin_src java
  // todo
  // 第一遍遍历使用一个栈来存链表，第二遍边遍历边弹栈比较
  // 快慢指针找中点，栈空间只存一半的节点
#+end_src
*** 4.3.2. 不用额外空间

#+begin_src java
  // todo
#+end_src

** 4.4. 将单向链表按某值划分成左边小，中间相等，右边大的形式
*** 4.4.1. 简单方法

放到数组里，变成荷兰国旗问题。
*** 4.4.2. 进阶要求

#+begin_quote
  （具有稳定性）调整前后，各个节点之间的相对位置不变，且时间复杂度：$O(N)$，空间复杂度：$O(1)$。

  如果对空间复杂度不做要求，那么可以用三个队列存储小于部分，等于部分，大于部分，然后将三个部分首尾连接起来。
#+end_quote

** 4.5. 复制含有随机指针节点的链表
*** 4.5.1. 简单方法（使用额外空间）

使用哈希表=Map<Node,Node>=，key为原始节点，value为克隆key得到的节点。value节点的next和random指针都能通过map查询得到。
*** 4.5.2. 不用额外空间

第一遍遍历，在原链表的每个节点后面插入一个克隆节点，第二遍遍历填入random指针，最后把原节点和克隆节点分离开，恢复输入链表，得到克隆链表。
** 4.6. 两个单链表相交的一系列问题

#+begin_quote
  给定两个有可能有环也可能无环的单链表，头节点head1，head2。如果相交，返回相交的第一个节点，如果不相交返回null。要求：两链表长度和为$N$，时间复杂度$O(N)$，空间复杂度$O(1)$。
#+end_quote
*** 4.6.1. 简单方法

#+begin_quote
  使用Set做辅助记录
#+end_quote
*** 4.6.2. 找到单链表成环的第一个节点

使用快慢指针，准备快指针F，慢指针S，快指针一次走两步，满指针一次走一步。如果快指针走到null，那么不存在环。否则有环，而且快指针和慢指针会在环上相遇。然后快指针跳回头节点，与慢指针一样一次走一步，快慢指针再次相遇的节点就是成环的节点。
*** 4.6.3. 找到两个单链表相交的第一个节点

#+begin_quote
  两个无环链表的相交问题。
#+end_quote

遍历两个链表并记录长度，以及比较两个链表的尾节点，如果存在相交，那么两个链表的尾节点一定相同。判定相交后，让较长链表的指针先走两链表长度之差步，然后两个指针一起走，走到第一个节点相同的位置就是两个链表相交的点。
*** 4.6.4. 两个有环链表

#+begin_quote
  存在3种情况
#+end_quote

1. 两个链表独立成环（不相交）
2. 两个链表在环外相交
3. 两个链表分别指向了环上的两个位置

三种情况的判断：对于两个链表可以得到，head1，head2，loop1，loop2。

1. 如果loop1 == loop2，那么就是第二种情况，即两条链表先相交后成环。
2. loop1 !=
   loop2，让指针在loop1环内遍历一遍（由成环的交点出发，一步一步走又回到出发点）如果发现了loop2，那么是第三种情况，即两个链表分别指向了换上的两个节点。如果遍历loop1一遍始终没有发现loop2节点，那么就是第一种情况，即两条链表独立成环。

对于第三种情况而言，loop1和loop2都是两个链表的交点。
*** 4.6.5. 一个链表有环，一个链表无环

#+begin_quote
  不可能相交
#+end_quote

** 4.7. 链表问题的解题方法论
*** 4.7.1. 笔试

时间复杂度第一位，但不那么在意空间复杂度。
*** 4.7.2. 面试

时间复杂度第一位，同时尽量使用最省空间的方法。
** 4.8. 重要技巧

1. 使用额外数据结构记录（哈希表）
2. 快慢指针
