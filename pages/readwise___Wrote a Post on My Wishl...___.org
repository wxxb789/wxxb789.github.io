:PROPERTIES:
:title: readwise/Wrote a Post on My Wishl...
:END:


* metadata
:PROPERTIES:
:author: [[eatonphil on Twitter]]
:full-title: "Wrote a Post on My Wishl..."
:category: [[tweets]]
:url: https://twitter.com/eatonphil/status/1768725864923931033
:image-url: https://pbs.twimg.com/profile_images/1514261712148615175/f7HovNJE.jpg
:END:

* Highlights first synced by [[Readwise]] [[2024-03-19]]
** ðŸ“Œ [[2024-03-16]]
#+BEGIN_QUOTE
Wrote a post on my wishlist for Zig and Rust. Focused on automatic memory management, the standard library, and explicit allocation.

https://t.co/dvynizU9V2 

![](https://pbs.twimg.com/media/GIvGer7X0AASlnR.jpg) 
#+END_QUOTE\
** ðŸ“Œ [[2024-03-16]]
#+BEGIN_QUOTE
First, I think Zig would be a stronger language if it supported RAII.

You can explicitly defer but you can't have automatic cleanup code. i.e. you can forget to defer. 

![](https://pbs.twimg.com/media/GIvfkc_WIAAOV16.jpg) 
#+END_QUOTE\
** ðŸ“Œ [[2024-03-16]]
#+BEGIN_QUOTE
Second, the trend toward smaller standard libraries is producing some weird (or at the very least not ideal) incentives. 

![](https://pbs.twimg.com/media/GIvfugEWAAEUlTH.jpg) 
#+END_QUOTE\
** ðŸ“Œ [[2024-03-16]]
#+BEGIN_QUOTE
Lastly, what I was talking about earlier today, explicit allocation can be pretty nice actually.

On the other hand it's sort of a visual hack.

At a minimum, when I write Rust or C code I can never tell if I'm calling a function allocates. For the most part in Zig you can. 

![](https://pbs.twimg.com/media/GIvf7yLXgAASISt.jpg) 
#+END_QUOTE\